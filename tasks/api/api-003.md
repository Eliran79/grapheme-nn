---
id: api-003
title: Define Memory Architecture Traits (Phase 2)
status: todo
priority: high
tags:
- api
- cognitive
- memory
dependencies:
- api-002
assignee: developer
created: 2025-12-05T22:06:37.846539852Z
estimate: ~
complexity: 4
area: api
---

# Define Memory Architecture Traits (Phase 2)

## Context
Current GRAPHEME has no long-term knowledge accumulation. Each inference is stateless - the system cannot learn from experience, accumulate knowledge, or maintain context across interactions.

**Gap Analysis**: Without memory, GRAPHEME cannot:
- Remember previous interactions or reasoning chains
- Accumulate semantic knowledge over time
- Learn procedures and skills
- Maintain working context during complex reasoning

## Objectives
- Define trait interfaces for four memory types
- Enable graph-based memory storage and retrieval
- Support continual learning without catastrophic forgetting
- Integrate with GRAPHEME's graph-native architecture

## Tasks
- [ ] Define `EpisodicMemory` trait (specific experiences)
- [ ] Define `SemanticGraph` trait (general knowledge)
- [ ] Define `ProceduralMemory` trait (skills/procedures)
- [ ] Define `WorkingMemory` trait (active context)
- [ ] Define `ContinualLearning` trait (memory consolidation)
- [ ] Define `MemorySystem` unified struct
- [ ] Create `grapheme-memory` crate skeleton
- [ ] Add trait documentation with usage examples
- [ ] Write trait compliance tests

## Acceptance Criteria
✅ **Completeness:**
- All four memory types have defined traits
- Memory consolidation/integration defined
- Graph-native storage format specified

✅ **Integration:**
- Traits work with existing Graph types
- Compatible with training pipeline
- Supports retrieval-augmented generation pattern

✅ **Testability:**
- Trait objects can be mocked
- Memory operations are deterministic
- Clear success/failure semantics

## Technical Notes

### Core Structures
```rust
/// Unified memory system combining all memory types
pub struct MemorySystem {
    pub episodic: Box<dyn EpisodicMemory>,      // Specific experiences with temporal context
    pub semantic: Box<dyn SemanticGraph>,        // General knowledge (facts, concepts)
    pub procedural: Box<dyn ProceduralMemory>,   // How to do things
    pub working: Box<dyn WorkingMemory>,         // Active reasoning context
}

/// Temporal context for episodic memories
pub struct Episode {
    pub id: EpisodeId,
    pub timestamp: Timestamp,
    pub context: Graph,           // Situation graph
    pub content: Graph,           // What happened
    pub outcome: Option<Graph>,   // Result/consequence
    pub emotional_valence: f32,   // For prioritization
}
```

### Trait Definitions
```rust
/// Episodic memory: stores specific experiences with temporal context
pub trait EpisodicMemory: Send + Sync {
    /// Store a new episode
    fn store(&mut self, episode: Episode) -> EpisodeId;

    /// Retrieve episodes similar to query
    fn recall(&self, query: &Graph, limit: usize) -> Vec<Episode>;

    /// Retrieve episodes from time range
    fn recall_temporal(&self, start: Timestamp, end: Timestamp) -> Vec<Episode>;

    /// Forget old/unimportant episodes (memory management)
    fn consolidate(&mut self, retention_policy: &RetentionPolicy);
}

/// Semantic memory: general knowledge graph
pub trait SemanticGraph: Send + Sync {
    /// Add fact to knowledge graph
    fn assert(&mut self, fact: Graph) -> FactId;

    /// Query knowledge graph
    fn query(&self, pattern: &Graph) -> Vec<Graph>;

    /// Check if fact is known
    fn contains(&self, fact: &Graph) -> bool;

    /// Get all facts about an entity
    fn about(&self, entity: NodeId) -> Graph;

    /// Update fact (with provenance tracking)
    fn revise(&mut self, old: &Graph, new: Graph, source: Source);
}

/// Procedural memory: learned skills and procedures
pub trait ProceduralMemory: Send + Sync {
    /// Store a procedure (graph transformation pattern)
    fn learn(&mut self, name: &str, procedure: TransformRule);

    /// Retrieve procedure by name
    fn recall(&self, name: &str) -> Option<&TransformRule>;

    /// Find applicable procedures for situation
    fn applicable(&self, situation: &Graph) -> Vec<&TransformRule>;

    /// Improve procedure based on feedback
    fn refine(&mut self, name: &str, feedback: ProcedureFeedback);
}

/// Working memory: active reasoning context
pub trait WorkingMemory: Send + Sync {
    /// Current capacity (number of active items)
    fn capacity(&self) -> usize;

    /// Add item to working memory (may evict old items)
    fn attend(&mut self, item: Graph) -> Option<Graph>; // Returns evicted item

    /// Get all items in working memory
    fn contents(&self) -> &[Graph];

    /// Clear working memory
    fn clear(&mut self);

    /// Focus on specific item (boost its priority)
    fn focus(&mut self, item: &Graph);
}

/// Continual learning: consolidation and integration
pub trait ContinualLearning: Send + Sync {
    /// Consolidate new experience without forgetting old
    fn consolidate(&mut self, new_experience: Graph);

    /// Detect and resolve contradictions
    fn reconcile(&mut self, new_fact: Graph, existing: &dyn SemanticGraph)
        -> ReconciliationResult;

    /// Sleep-like offline processing (replay and integrate)
    fn replay_and_integrate(&mut self);

    /// Estimate knowledge coverage
    fn coverage(&self, domain: &Graph) -> f32;
}
```

### Key Design Decisions
- All memories store/retrieve Graphs (native to GRAPHEME)
- Episodic has temporal ordering; semantic is atemporal
- Working memory has limited capacity (like human WM ~7±2 items)
- Continual learning handles contradictions explicitly
- Traits are object-safe for runtime polymorphism

### Files to Create
- `grapheme-memory/Cargo.toml`: New crate definition
- `grapheme-memory/src/lib.rs`: Trait definitions
- `grapheme-memory/src/episodic.rs`: EpisodicMemory trait + types
- `grapheme-memory/src/semantic.rs`: SemanticGraph trait + types
- `grapheme-memory/src/procedural.rs`: ProceduralMemory trait + types
- `grapheme-memory/src/working.rs`: WorkingMemory trait + types
- `grapheme-memory/src/continual.rs`: ContinualLearning trait

## Testing
- [ ] Trait object creation compiles
- [ ] Mock implementations work
- [ ] Storage/retrieval round-trips correctly
- [ ] Working memory capacity limits work
- [ ] Consolidation doesn't panic

## Updates
- 2025-12-05: Task created from AGI gap analysis

## Session Handoff (AI: Complete this when marking task done)
**For the next session/agent working on dependent tasks:**

### What Changed
- [Document code changes, new files, modified functions]

### Causality Impact
- Enables stateful reasoning across interactions
- Foundation for retrieval-augmented generation
- Required by: api-004 (Reasoning), api-007 (Meta-Cognition)

### Dependencies & Integration
- Depends on: api-002 (core traits for Graph types)
- Required by: backend-015, backend-016, backend-017

### Verification & Testing
- `cargo test -p grapheme-memory`
- Verify traits are object-safe
- Test mock implementations
